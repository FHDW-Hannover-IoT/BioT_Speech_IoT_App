package com.fhdw.biot.speech.iot;

import android.os.Bundle;
import android.util.Log;
import android.widget.Button;
import android.widget.ImageButton;
import android.widget.TextView;
import android.widget.Toast;

import androidx.activity.EdgeToEdge;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.graphics.Insets;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;

import java.util.List;
import java.util.Locale;
import java.util.UUID;

import database.DB;
import database.dao.SensorDao;
import database.dao.ValueSensorDAO;
import database.entities.AccelData;
import database.entities.GyroData;
import database.entities.ValueSensor;

/**
 * MainActivity
 * ------------
 * MQTT-based version:
 *  - NO real Android sensors are used anymore.
 *  - Fake values are generated by {@link SensorDataSimulator} and published via MQTT.
 *  - This Activity subscribes to the topics, updates the UI and writes into Room.
 *
 * Publisher side:
 *  - SensorDataSimulator → mqttHandler.publish(...)
 *
 * Subscriber side (this Activity):
 *  - mqttHandler.subscribe("Sensor/Bewegung" / "Sensor/Gyro" / "Sensor/Zeit")
 *  - mqttHandler → onMessageReceived(...) → handleMovement / handleGyro / handleTime
 *  - UI TextViews are updated
 *  - DB entities (AccelData / GyroData / ValueSensor) are stored.
 */
public class MainActivity extends AppCompatActivity {

    // ---- MQTT broker urls ---------------------------------------------------

    /** Broker for a *real phone* on the same LAN as your PC. */
    private static final String PHONE_BROKER = "tcp://192.168.178.80:1883";

    /** Broker for the *Android emulator* (10.0.2.2 = host PC). */
    private static final String EMULATOR_BROKER = "tcp://10.0.2.2:1883";

    private static final String TAG = "MainActivity";

    // ---- MQTT objects -------------------------------------------------------

    private MqttHandler mqttHandler;
    private SensorDataSimulator dataSimulator;

    // ---- ROOM DAOs ----------------------------------------------------------

    private SensorDao sensorDao;           // accel / gyro tables etc.
    private ValueSensorDAO valueSensorDao; // combined ValueSensor table

    // ---- UI elements --------------------------------------------------------

    // We reuse your existing TextViews from the sensor app:
    //  - Bewegung (accelerometer-like) → accelX/Y/ZValue
    //  - Gyro                            → gyroX/Y/ZValue
    //  - Zeit timestamp                  → we show in accelZValue for demo (or add a dedicated TextView).
    private TextView accelXValue, accelYValue, accelZValue;
    private TextView gyroXValue, gyroYValue, gyroZValue;
    private TextView magXValue, magYValue, magZValue; // can be used for time or left unused

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        EdgeToEdge.enable(this);
        setContentView(R.layout.activity_main);

        // ---- edge-to-edge padding ------------------------------------------
        ViewCompat.setOnApplyWindowInsetsListener(
                findViewById(R.id.main),
                (v, insets) -> {
                    Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());
                    v.setPadding(
                            systemBars.left,
                            systemBars.top,
                            systemBars.right,
                            systemBars.bottom);
                    return insets;
                });

        // ---- navigation buttons --------------------------------------------
        Button buttonGyro = findViewById(R.id.btnGyro);
        buttonGyro.setOnClickListener(
                view -> startActivity(new android.content.Intent(MainActivity.this, GyroActivity.class)));

        Button buttonAccel = findViewById(R.id.btnAccel);
        buttonAccel.setOnClickListener(
                view -> startActivity(new android.content.Intent(MainActivity.this, AccelActivity.class)));

        Button buttonMagnet = findViewById(R.id.btnMagnet);
        buttonMagnet.setOnClickListener(
                view -> startActivity(new android.content.Intent(MainActivity.this, MagnetActivity.class)));

        ImageButton ereignisButton = findViewById(R.id.notification_button);
        ereignisButton.setOnClickListener(
                view -> {
                    android.content.Intent intent =
                            new android.content.Intent(MainActivity.this, EreignisActivity.class);
                    intent.putExtra("SENSOR_FILTER", "ALL");
                    startActivity(intent);
                });

        Button graphButton = findViewById(R.id.graphenansicht);
        graphButton.setOnClickListener(
                view -> startActivity(new android.content.Intent(MainActivity.this, MainGraphActivity.class)));

        // ---- bind TextViews -------------------------------------------------
        accelXValue = findViewById(R.id.accelXValue);
        accelYValue = findViewById(R.id.accelYValue);
        accelZValue = findViewById(R.id.accelZValue);

        gyroXValue = findViewById(R.id.gyroXValue);
        gyroYValue = findViewById(R.id.gyroYValue);
        gyroZValue = findViewById(R.id.gyroZValue);

        magXValue = findViewById(R.id.magXValue);
        magYValue = findViewById(R.id.magYValue);
        magZValue = findViewById(R.id.magZValue);

        // ---- Room: DB / DAOs ----------------------------------------------
        DB db = DB.getDatabase(this);
        sensorDao = db.sensorDao();
        valueSensorDao = db.valueSensorDao();

        // ---- MQTT: create client ------------------------------------------
        final String clientId = "Nutzer_" + UUID.randomUUID().toString().substring(0, 8);
        final String brokerUrl = getBrokerUrl();

        Log.i(TAG, "Using brokerUrl=" + brokerUrl + " clientId=" + clientId);

        try {
            mqttHandler = new MqttHandler(brokerUrl, clientId);
        } catch (Exception e) {
            Log.e(TAG, "Failed to create MqttHandler: " + e.getMessage(), e);
            Toast.makeText(this,
                    "MQTT client creation failed: " + e.getMessage(),
                    Toast.LENGTH_LONG).show();
            return;
        }

        // ---- MQTT: incoming message listener ------------------------------
        mqttHandler.setMessageListener((topic, message) -> {
            Log.i(TAG, "MQTT message → topic=" + topic + " payload=" + message);

            runOnUiThread(() -> {
                try {
                    switch (topic) {
                        case "Sensor/Bewegung":
                            handleMovementMessage(message);
                            break;
                        case "Sensor/Gyro":
                            handleGyroMessage(message);
                            break;
                        case "Sensor/Zeit":
                            handleTimeMessage(message);
                            break;
                        default:
                            Log.w(TAG, "Unhandled topic: " + topic);
                    }
                } catch (Exception ex) {
                    Log.e(TAG, "Error handling MQTT message: " + ex.getMessage(), ex);
                }
            });
        });

        // ---- MQTT: connect & then subscribe + start simulator -------------
        mqttHandler.connect(new MqttHandler.ConnectionListener() {
            @Override
            public void onConnected() {
                Log.i(TAG, "MQTT connected");

                runOnUiThread(() ->
                        Toast.makeText(MainActivity.this,
                                "MQTT verbunden", Toast.LENGTH_SHORT).show());

                mqttHandler.subscribe("Sensor/Bewegung");
                mqttHandler.subscribe("Sensor/Gyro");
                mqttHandler.subscribe("Sensor/Zeit");

                // just for debugging:
                loadDatabaseValues();

                // Start the fake data publisher: "remote sensor"
                dataSimulator = new SensorDataSimulator(mqttHandler, 1000L);
                dataSimulator.start();
            }

            @Override
            public void onFailure(Throwable t) {
                Log.e(TAG, "MQTT connect failed: " +
                        (t == null ? "unknown" : t.getMessage()), t);

                runOnUiThread(() ->
                        Toast.makeText(MainActivity.this,
                                "MQTT Fehler: " +
                                        (t == null ? "unknown" : t.getMessage()),
                                Toast.LENGTH_LONG).show());
            }
        });
    }

    // ------------------------------------------------------------------------
    // Lifecycle: cleanup
    // ------------------------------------------------------------------------
    @Override
    protected void onDestroy() {
        if (dataSimulator != null) {
            dataSimulator.stop();
        }
        if (mqttHandler != null) {
            mqttHandler.disconnect();
        }
        super.onDestroy();
    }

    // ------------------------------------------------------------------------
    // MQTT message handlers → UI + DB
    // ------------------------------------------------------------------------

    /** Handle "Sensor/Bewegung" payload: CSV "x,y,z". */
    private void handleMovementMessage(String message) {
        String[] p = message.split(",");
        if (p.length < 3) {
            Log.w(TAG, "Movement: not enough values: " + message);
            return;
        }

        try {
            float x = Float.parseFloat(p[0].trim());
            float y = Float.parseFloat(p[1].trim());
            float z = Float.parseFloat(p[2].trim());

            // UI (reuse your existing strings for accelerometer)
            accelXValue.setText(getString(R.string.beschleunigung_x, x));
            accelYValue.setText(getString(R.string.beschleunigung_y, y));
            accelZValue.setText(getString(R.string.beschleunigung_z, z));

            long now = System.currentTimeMillis();

            // DB: accel_data row
            AccelData accelData = new AccelData();
            accelData.timestamp = now;
            accelData.accelX = x;
            accelData.accelY = y;
            accelData.accelZ = z;

            // DB: ValueSensor row (movement part)
            ValueSensor vs = new ValueSensor();
            vs.value1 = x;
            vs.value2 = y;
            vs.value3 = z;

            DB.databaseWriteExecutor.execute(() -> {
                sensorDao.insert(accelData);
                valueSensorDao.insert(vs);
            });

        } catch (NumberFormatException e) {
            Log.e(TAG, "Movement parse error: " + e.getMessage(), e);
        }
    }

    /** Handle "Sensor/Gyro" payload: CSV "x,y,z". */
    private void handleGyroMessage(String message) {
        String[] g = message.split(",");
        if (g.length < 3) {
            Log.w(TAG, "Gyro: not enough values: " + message);
            return;
        }

        try {
            float x = Float.parseFloat(g[0].trim());
            float y = Float.parseFloat(g[1].trim());
            float z = Float.parseFloat(g[2].trim());

            // UI
            gyroXValue.setText(getString(R.string.gyro_x, x));
            gyroYValue.setText(getString(R.string.gyro_y, y));
            gyroZValue.setText(getString(R.string.gyro_z, z));

            long now = System.currentTimeMillis();

            // DB: gyro_data row
            GyroData gyroData = new GyroData();
            gyroData.timestamp = now;
            gyroData.gyroX = x;
            gyroData.gyroY = y;
            gyroData.gyroZ = z;

            // DB: ValueSensor row (gyro part)
            ValueSensor vs = new ValueSensor();
            vs.value4 = x;
            vs.value5 = y;
            vs.value6 = z;

            DB.databaseWriteExecutor.execute(() -> {
                sensorDao.insert(gyroData);
                valueSensorDao.insert(vs);
            });

        } catch (NumberFormatException e) {
            Log.e(TAG, "Gyro parse error: " + e.getMessage(), e);
        }
    }

    /** Handle "Sensor/Zeit" payload: plain timestamp string. */
    private void handleTimeMessage(String message) {
        // UI: for now, just print it into magXValue (or change to a dedicated TextView)
        magXValue.setText(message);

        // DB: store in ValueSensor.value7
        ValueSensor vs = new ValueSensor();
        vs.value7 = message;

        DB.databaseWriteExecutor.execute(() -> valueSensorDao.insert(vs));
    }

    // ------------------------------------------------------------------------
    // DB debug helper
    // ------------------------------------------------------------------------
    private void loadDatabaseValues() {
        DB.databaseWriteExecutor.execute(() -> {
            try {
                List<ValueSensor> list = valueSensorDao.getAllvalue();
                Log.i(TAG, "ValueSensor DB SIZE = " + list.size());
            } catch (Exception e) {
                Log.e(TAG, "loadDatabaseValues error: " + e.getMessage(), e);
            }
        });
    }

    // ------------------------------------------------------------------------
    // Emulator detection → choose correct broker URL
    // ------------------------------------------------------------------------
    private String getBrokerUrl() {
        String f = (android.os.Build.FINGERPRINT == null ? "" : android.os.Build.FINGERPRINT).toLowerCase(Locale.US);
        String m = (android.os.Build.MODEL == null ? "" : android.os.Build.MODEL).toLowerCase(Locale.US);
        String p = (android.os.Build.PRODUCT == null ? "" : android.os.Build.PRODUCT).toLowerCase(Locale.US);

        boolean isEmulator =
                f.startsWith("generic") ||
                        f.contains("vbox") ||
                        f.contains("test-keys") ||
                        m.contains("google_sdk") ||
                        m.contains("emulator") ||
                        m.contains("android sdk built for x86") ||
                        p.contains("sdk_gphone");

        return isEmulator ? EMULATOR_BROKER : PHONE_BROKER;
    }
}
