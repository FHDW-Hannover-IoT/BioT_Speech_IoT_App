package com.fhdw.biot.speech.iot.main;

import android.os.Bundle;
import android.util.Log;
import android.widget.Button;
import android.widget.ImageButton;
import android.widget.TextView;
import android.widget.Toast;
import androidx.activity.EdgeToEdge;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.graphics.Insets;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;
import com.fhdw.biot.speech.iot.R;
import com.fhdw.biot.speech.iot.events.EreignisActivity;
import com.fhdw.biot.speech.iot.graph.MainGraphActivity;
import com.fhdw.biot.speech.iot.mqtt.MqttHandler;
import com.fhdw.biot.speech.iot.sensor.AccelActivity;
import com.fhdw.biot.speech.iot.sensor.GyroActivity;
import com.fhdw.biot.speech.iot.sensor.MagnetActivity;
import com.fhdw.biot.speech.iot.settings.SettingsActivity;
import com.fhdw.biot.speech.iot.simulation.SensorDataSimulator;
import database.DB;
import database.dao.SensorDao;
import database.dao.ValueSensorDAO;
import database.entities.AccelData;
import database.entities.GyroData;
import database.entities.MagnetData;
import database.entities.ValueSensor;
import java.util.List;
import java.util.Locale;
import java.util.UUID;

/**
 * MainActivity ------------ MQTT-based version: - NO real Android sensors are used anymore. - Fake
 * values are generated by {@link SensorDataSimulator} and published via MQTT. - This Activity
 * subscribes to the topics, updates the UI and writes into Room.
 *
 * <p>Publisher side: - SensorDataSimulator → mqttHandler.publish(...)
 *
 * <p>Subscriber side (this Activity): - mqttHandler.subscribe("Sensor/Bewegung" / "Sensor/Gyro" /
 * "Sensor/Magnet") - mqttHandler → onMessageReceived(...) → handleMovement / handleGyro /
 * handleMagnet - UI TextViews are updated - DB entities (AccelData / GyroData / MagnetData /
 * ValueSensor) are stored.
 */
public class MainActivity extends AppCompatActivity {

    // ---- MQTT broker urls ---------------------------------------------------

    /** Broker for a *real phone* on the same LAN as your PC. */
    private static final String PHONE_BROKER = "tcp://192.168.178.80:1883";

    /** Broker for the *Android emulator* (10.0.2.2 = host PC). */
    private static final String EMULATOR_BROKER = "tcp://10.0.2.2:1883";

    private static final String TAG = "MainActivity";

    // ---- MQTT objects -------------------------------------------------------

    private MqttHandler mqttHandler;
    private SensorDataSimulator dataSimulator;

    // ---- ROOM DAOs ----------------------------------------------------------

    private SensorDao sensorDao; // accel / gyro / magnet tables etc.
    private ValueSensorDAO valueSensorDao; // combined ValueSensor table

    // ---- UI elements --------------------------------------------------------
    // We reuse your existing TextViews from the sensor app:
    //  - Bewegung (accelerometer-like) → accelX/Y/ZValue
    //  - Gyro                          → gyroX/Y/ZValue
    //  - Magnet                        → magX/Y/ZValue
    private TextView accelXValue, accelYValue, accelZValue;
    private TextView gyroXValue, gyroYValue, gyroZValue;
    private TextView magXValue, magYValue, magZValue;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        EdgeToEdge.enable(this);
        setContentView(R.layout.activity_main);

        // ---- edge-to-edge padding ------------------------------------------
        ViewCompat.setOnApplyWindowInsetsListener(
                findViewById(R.id.main),
                (v, insets) -> {
                    Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());
                    v.setPadding(
                            systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);
                    return insets;
                });

        // ---- navigation buttons --------------------------------------------
        Button buttonGyro = findViewById(R.id.btnGyro);
        buttonGyro.setOnClickListener(
                view ->
                        startActivity(
                                new android.content.Intent(MainActivity.this, GyroActivity.class)));

        Button buttonAccel = findViewById(R.id.btnAccel);
        buttonAccel.setOnClickListener(
                view ->
                        startActivity(
                                new android.content.Intent(
                                        MainActivity.this, AccelActivity.class)));

        Button buttonMagnet = findViewById(R.id.btnMagnet);
        buttonMagnet.setOnClickListener(
                view ->
                        startActivity(
                                new android.content.Intent(
                                        MainActivity.this, MagnetActivity.class)));

        ImageButton ereignisButton = findViewById(R.id.notification_button);
        ereignisButton.setOnClickListener(
                view -> {
                    android.content.Intent intent =
                            new android.content.Intent(MainActivity.this, EreignisActivity.class);
                    intent.putExtra("SENSOR_FILTER", "ALL");
                    startActivity(intent);
                });

        Button graphButton = findViewById(R.id.graphenansicht);
        graphButton.setOnClickListener(
                view ->
                        startActivity(
                                new android.content.Intent(
                                        MainActivity.this, MainGraphActivity.class)));

        ImageButton settingsButton = findViewById(R.id.settings_button);
        settingsButton.setOnClickListener(
                view ->
                        startActivity(
                                new android.content.Intent(
                                        MainActivity.this, SettingsActivity.class)));

        // ---- bind TextViews -------------------------------------------------
        accelXValue = findViewById(R.id.accelXValue);
        accelYValue = findViewById(R.id.accelYValue);
        accelZValue = findViewById(R.id.accelZValue);

        gyroXValue = findViewById(R.id.gyroXValue);
        gyroYValue = findViewById(R.id.gyroYValue);
        gyroZValue = findViewById(R.id.gyroZValue);

        magXValue = findViewById(R.id.magXValue);
        magYValue = findViewById(R.id.magYValue);
        magZValue = findViewById(R.id.magZValue);

        // ---- Room: DB / DAOs ----------------------------------------------
        DB db = DB.getDatabase(this);
        sensorDao = db.sensorDao();
        valueSensorDao = db.valueSensorDao();

        // ---- MQTT: create client ------------------------------------------
        final String clientId = "Nutzer_" + UUID.randomUUID().toString().substring(0, 8);
        final String brokerUrl = getBrokerUrl();

        Log.i(TAG, "Using brokerUrl=" + brokerUrl + " clientId=" + clientId);

        try {
            mqttHandler = new MqttHandler(brokerUrl, clientId);
        } catch (Exception e) {
            Log.e(TAG, "Failed to create MqttHandler: " + e.getMessage(), e);
            Toast.makeText(
                            this,
                            "MQTT client creation failed: " + e.getMessage(),
                            Toast.LENGTH_LONG)
                    .show();
            return;
        }

        // ---- MQTT: incoming message listener ------------------------------
        mqttHandler.setMessageListener(
                (topic, message) -> {
                    Log.i(TAG, "MQTT message → topic=" + topic + " payload=" + message);

                    runOnUiThread(
                            () -> {
                                try {
                                    switch (topic) {
                                        case "Sensor/Bewegung":
                                            handleMovementMessage(message);
                                            break;
                                        case "Sensor/Gyro":
                                            handleGyroMessage(message);
                                            break;
                                        case "Sensor/Magnet":
                                            handleMagnetMessage(message);
                                            break;
                                        default:
                                            Log.w(TAG, "Unhandled topic: " + topic);
                                    }
                                } catch (Exception ex) {
                                    Log.e(
                                            TAG,
                                            "Error handling MQTT message: " + ex.getMessage(),
                                            ex);
                                }
                            });
                });

        // ---- MQTT: connect & then subscribe + start simulator -------------
        mqttHandler.connect(
                new MqttHandler.ConnectionListener() {
                    @Override
                    public void onConnected() {
                        Log.i(TAG, "MQTT connected");

                        runOnUiThread(
                                () ->
                                        Toast.makeText(
                                                        MainActivity.this,
                                                        "MQTT verbunden",
                                                        Toast.LENGTH_SHORT)
                                                .show());

                        mqttHandler.subscribe("Sensor/Bewegung");
                        mqttHandler.subscribe("Sensor/Gyro");
                        mqttHandler.subscribe("Sensor/Magnet");

                        // just for debugging:
                        loadDatabaseValues();

                        // Start the fake data publisher: "remote sensor"
                        dataSimulator = new SensorDataSimulator(mqttHandler, 1000L);
                        dataSimulator.start();
                    }

                    @Override
                    public void onFailure(Throwable t) {
                        Log.e(
                                TAG,
                                "MQTT connect failed: " + (t == null ? "unknown" : t.getMessage()),
                                t);

                        runOnUiThread(
                                () ->
                                        Toast.makeText(
                                                        MainActivity.this,
                                                        "MQTT Fehler: "
                                                                + (t == null
                                                                        ? "unknown"
                                                                        : t.getMessage()),
                                                        Toast.LENGTH_LONG)
                                                .show());
                    }
                });
    }

    // ------------------------------------------------------------------------
    // Lifecycle: cleanup
    // ------------------------------------------------------------------------
    @Override
    protected void onDestroy() {
        if (dataSimulator != null) {
            dataSimulator.stop();
        }
        if (mqttHandler != null) {
            mqttHandler.disconnect();
        }
        super.onDestroy();
    }

    // ------------------------------------------------------------------------
    // MQTT message handlers → UI + DB
    // ------------------------------------------------------------------------

    /** Handle "Sensor/Bewegung" payload: CSV "x,y,z". */
    private void handleMovementMessage(String message) {
        String[] p = message.split(",");
        if (p.length < 3) {
            Log.w(TAG, "Movement: not enough values: " + message);
            return;
        }

        try {
            float x = Float.parseFloat(p[0].trim());
            float y = Float.parseFloat(p[1].trim());
            float z = Float.parseFloat(p[2].trim());

            // UI (reuse your existing strings for accelerometer)
            accelXValue.setText(getString(R.string.beschleunigung_x, x));
            accelYValue.setText(getString(R.string.beschleunigung_y, y));
            accelZValue.setText(getString(R.string.beschleunigung_z, z));

            long now = System.currentTimeMillis();

            // DB: accel_data row
            AccelData accelData = new AccelData();
            accelData.timestamp = now;
            accelData.accelX = x;
            accelData.accelY = y;
            accelData.accelZ = z;

            // DB: ValueSensor row (movement part)
            ValueSensor vs = new ValueSensor();
            vs.value1 = x;
            vs.value2 = y;
            vs.value3 = z;

            DB.databaseWriteExecutor.execute(
                    () -> {
                        sensorDao.insert(accelData);
                        valueSensorDao.insert(vs);
                    });

        } catch (NumberFormatException e) {
            Log.e(TAG, "Movement parse error: " + e.getMessage(), e);
        }
    }

    /** Handle "Sensor/Gyro" payload: CSV "x,y,z". */
    private void handleGyroMessage(String message) {
        String[] g = message.split(",");
        if (g.length < 3) {
            Log.w(TAG, "Gyro: not enough values: " + message);
            return;
        }

        try {
            float x = Float.parseFloat(g[0].trim());
            float y = Float.parseFloat(g[1].trim());
            float z = Float.parseFloat(g[2].trim());

            // UI
            gyroXValue.setText(getString(R.string.gyro_x, x));
            gyroYValue.setText(getString(R.string.gyro_y, y));
            gyroZValue.setText(getString(R.string.gyro_z, z));

            long now = System.currentTimeMillis();

            // DB: gyro_data row
            GyroData gyroData = new GyroData();
            gyroData.timestamp = now;
            gyroData.gyroX = x;
            gyroData.gyroY = y;
            gyroData.gyroZ = z;

            // DB: ValueSensor row (gyro part)
            ValueSensor vs = new ValueSensor();
            vs.value4 = x;
            vs.value5 = y;
            vs.value6 = z;

            DB.databaseWriteExecutor.execute(
                    () -> {
                        sensorDao.insert(gyroData);
                        valueSensorDao.insert(vs);
                    });

        } catch (NumberFormatException e) {
            Log.e(TAG, "Gyro parse error: " + e.getMessage(), e);
        }
    }

    /** Handle "Sensor/Magnet" payload: CSV "x,y,z". */
    private void handleMagnetMessage(String message) {
        String[] m = message.split(",");
        if (m.length < 3) {
            Log.w(TAG, "Magnet: not enough values: " + message);
            return;
        }

        try {
            float x = Float.parseFloat(m[0].trim());
            float y = Float.parseFloat(m[1].trim());
            float z = Float.parseFloat(m[2].trim());

            // UI – show magnet vector components
            magXValue.setText(getString(R.string.magnet_x, x));
            magYValue.setText(getString(R.string.magnet_y, y));
            magZValue.setText(getString(R.string.magnet_z, z));

            long now = System.currentTimeMillis();

            // DB: magnet_data row
            MagnetData magnetData = new MagnetData();
            magnetData.timestamp = now;
            magnetData.magnetX = x;
            magnetData.magnetY = y;
            magnetData.magnetZ = z;

            // If you later extend ValueSensor with magnet fields, you can also fill them here.
            DB.databaseWriteExecutor.execute(
                    () -> {
                        sensorDao.insert(magnetData);
                    });

        } catch (NumberFormatException e) {
            Log.e(TAG, "Magnet parse error: " + e.getMessage(), e);
        }
    }

    // ------------------------------------------------------------------------
    // DB debug helper
    // ------------------------------------------------------------------------
    private void loadDatabaseValues() {
        DB.databaseWriteExecutor.execute(
                () -> {
                    try {
                        List<ValueSensor> list = valueSensorDao.getAllvalue();
                        Log.i(TAG, "ValueSensor DB SIZE = " + list.size());
                    } catch (Exception e) {
                        Log.e(TAG, "loadDatabaseValues error: " + e.getMessage(), e);
                    }
                });
    }

    // ------------------------------------------------------------------------
    // Emulator detection → choose correct broker URL
    // ------------------------------------------------------------------------
    private String getBrokerUrl() {
        String f =
                (android.os.Build.FINGERPRINT == null ? "" : android.os.Build.FINGERPRINT)
                        .toLowerCase(Locale.US);
        String m =
                (android.os.Build.MODEL == null ? "" : android.os.Build.MODEL)
                        .toLowerCase(Locale.US);
        String p =
                (android.os.Build.PRODUCT == null ? "" : android.os.Build.PRODUCT)
                        .toLowerCase(Locale.US);

        boolean isEmulator =
                f.startsWith("generic")
                        || f.contains("vbox")
                        || f.contains("test-keys")
                        || m.contains("google_sdk")
                        || m.contains("emulator")
                        || m.contains("android sdk built for x86")
                        || p.contains("sdk_gphone");

        return isEmulator ? EMULATOR_BROKER : PHONE_BROKER;
    }
}
